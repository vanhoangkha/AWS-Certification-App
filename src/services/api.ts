// API service layer for AWS Certification Platform
// This will integrate with AppSync GraphQL API

import { generateClient } from 'aws-amplify/api'
import type { 
  Question, 
  QuestionInput, 
  ExamSession, 
  ExamResult, 
  UserProfile,
  StartExamInput,
  SaveProgressInput,
  QuestionFilters,
  CustomExamOptions
} from '@/types'

// Generate the AppSync client
const client = generateClient()

// GraphQL queries and mutations (will be auto-generated by Amplify)
const queries = {
  getQuestion: /* GraphQL */ `
    query GetQuestion($id: ID!) {
      getQuestion(id: $id) {
        questionId
        certification
        domain
        difficulty
        questionText
        questionType
        options
        correctAnswers
        explanation
        references
        tags
        createdBy
        createdAt
        updatedAt
      }
    }
  `,
  
  listQuestions: /* GraphQL */ `
    query ListQuestions($filter: ModelQuestionFilterInput, $limit: Int, $nextToken: String) {
      listQuestions(filter: $filter, limit: $limit, nextToken: $nextToken) {
        items {
          questionId
          certification
          domain
          difficulty
          questionText
          questionType
          options
          correctAnswers
          explanation
          references
          tags
          createdBy
          createdAt
          updatedAt
        }
        nextToken
      }
    }
  `,

  getQuestionsByFilters: /* GraphQL */ `
    query GetQuestionsByFilters(
      $certification: String!
      $domains: [String!]
      $difficulty: Difficulty
      $limit: Int
      $nextToken: String
    ) {
      getQuestionsByFilters(
        certification: $certification
        domains: $domains
        difficulty: $difficulty
        limit: $limit
        nextToken: $nextToken
      ) {
        items {
          questionId
          certification
          domain
          difficulty
          questionText
          questionType
          options
          correctAnswers
          explanation
          references
          tags
          createdBy
          createdAt
          updatedAt
        }
        nextToken
        total
      }
    }
  `,

  getNextPracticeQuestion: /* GraphQL */ `
    query GetNextPracticeQuestion(
      $certification: String!
      $domains: [String!]
      $difficulty: Difficulty
      $excludeQuestions: [String!]
    ) {
      getNextPracticeQuestion(
        certification: $certification
        domains: $domains
        difficulty: $difficulty
        excludeQuestions: $excludeQuestions
      ) {
        questionId
        certification
        domain
        difficulty
        questionText
        questionType
        options
        correctAnswers
        explanation
        references
        tags
        createdBy
        createdAt
        updatedAt
      }
    }
  `,

  getExamSession: /* GraphQL */ `
    query GetExamSession($id: ID!) {
      getExamSession(id: $id) {
        sessionId
        userId
        examType
        certification
        questions
        answers
        startTime
        endTime
        timeLimit
        status
        markedForReview
        createdAt
        updatedAt
      }
    }
  `,

  getExamResult: /* GraphQL */ `
    query GetExamResult($id: ID!) {
      getExamResult(id: $id) {
        resultId
        sessionId
        userId
        certification
        examType
        scaledScore
        passed
        domainBreakdown
        totalQuestions
        correctAnswers
        completedAt
        timeSpent
        createdAt
        updatedAt
      }
    }
  `,

  getUserProfile: /* GraphQL */ `
    query GetUserProfile($id: ID!) {
      getUserProfile(id: $id) {
        userId
        email
        name
        targetCertifications
        preferences
        createdAt
        updatedAt
      }
    }
  `
}

const mutations = {
  createQuestion: /* GraphQL */ `
    mutation CreateQuestion($input: CreateQuestionInput!) {
      createQuestion(input: $input) {
        questionId
        certification
        domain
        difficulty
        questionText
        questionType
        options
        correctAnswers
        explanation
        references
        tags
        createdBy
        createdAt
        updatedAt
      }
    }
  `,

  updateQuestion: /* GraphQL */ `
    mutation UpdateQuestion($input: UpdateQuestionInput!) {
      updateQuestion(input: $input) {
        questionId
        certification
        domain
        difficulty
        questionText
        questionType
        options
        correctAnswers
        explanation
        references
        tags
        createdBy
        createdAt
        updatedAt
      }
    }
  `,

  deleteQuestion: /* GraphQL */ `
    mutation DeleteQuestion($input: DeleteQuestionInput!) {
      deleteQuestion(input: $input) {
        questionId
      }
    }
  `,

  startExam: /* GraphQL */ `
    mutation StartExam($input: StartExamInput!) {
      startExam(input: $input) {
        sessionId
        userId
        examType
        certification
        questions
        answers
        startTime
        endTime
        timeLimit
        status
        markedForReview
        createdAt
        updatedAt
      }
    }
  `,

  saveExamProgress: /* GraphQL */ `
    mutation SaveExamProgress($input: SaveProgressInput!) {
      saveExamProgress(input: $input) {
        sessionId
        userId
        examType
        certification
        questions
        answers
        startTime
        endTime
        timeLimit
        status
        markedForReview
        createdAt
        updatedAt
      }
    }
  `,

  submitExam: /* GraphQL */ `
    mutation SubmitExam($sessionId: ID!) {
      submitExam(sessionId: $sessionId) {
        resultId
        sessionId
        userId
        certification
        examType
        scaledScore
        passed
        domainBreakdown
        totalQuestions
        correctAnswers
        completedAt
        timeSpent
        createdAt
        updatedAt
      }
    }
  `,

  createUserProfile: /* GraphQL */ `
    mutation CreateUserProfile($input: CreateUserProfileInput!) {
      createUserProfile(input: $input) {
        userId
        email
        name
        targetCertifications
        preferences
        createdAt
        updatedAt
      }
    }
  `,

  updateUserProfile: /* GraphQL */ `
    mutation UpdateUserProfile($input: UpdateUserProfileInput!) {
      updateUserProfile(input: $input) {
        userId
        email
        name
        targetCertifications
        preferences
        createdAt
        updatedAt
      }
    }
  `
}

// API Service Classes
export class QuestionAPI {
  static async getQuestion(questionId: string): Promise<Question | null> {
    try {
      const result = await client.graphql({
        query: queries.getQuestion,
        variables: { id: questionId }
      })
      return result.data.getQuestion
    } catch (error) {
      console.error('Error fetching question:', error)
      throw error
    }
  }

  static async getQuestionsByFilters(filters: QuestionFilters): Promise<{
    questions: Question[]
    nextToken?: string
    total?: number
  }> {
    try {
      const result = await client.graphql({
        query: queries.getQuestionsByFilters,
        variables: filters
      })
      return {
        questions: result.data.getQuestionsByFilters.items,
        nextToken: result.data.getQuestionsByFilters.nextToken,
        total: result.data.getQuestionsByFilters.total
      }
    } catch (error) {
      console.error('Error fetching questions by filters:', error)
      throw error
    }
  }

  static async getNextPracticeQuestion(
    certification: string,
    domains: string[],
    difficulty?: 'EASY' | 'MEDIUM' | 'HARD',
    excludeQuestions: string[] = []
  ): Promise<Question | null> {
    try {
      const result = await client.graphql({
        query: queries.getNextPracticeQuestion,
        variables: {
          certification,
          domains,
          difficulty,
          excludeQuestions
        }
      })
      return result.data.getNextPracticeQuestion
    } catch (error) {
      console.error('Error fetching next practice question:', error)
      throw error
    }
  }

  static async createQuestion(input: QuestionInput): Promise<Question> {
    try {
      const result = await client.graphql({
        query: mutations.createQuestion,
        variables: { input }
      })
      return result.data.createQuestion
    } catch (error) {
      console.error('Error creating question:', error)
      throw error
    }
  }

  static async updateQuestion(input: Partial<Question> & { questionId: string }): Promise<Question> {
    try {
      const result = await client.graphql({
        query: mutations.updateQuestion,
        variables: { input }
      })
      return result.data.updateQuestion
    } catch (error) {
      console.error('Error updating question:', error)
      throw error
    }
  }

  static async deleteQuestion(questionId: string): Promise<void> {
    try {
      await client.graphql({
        query: mutations.deleteQuestion,
        variables: { input: { questionId } }
      })
    } catch (error) {
      console.error('Error deleting question:', error)
      throw error
    }
  }
}

export class ExamAPI {
  static async startExam(input: StartExamInput): Promise<ExamSession> {
    try {
      const result = await client.graphql({
        query: mutations.startExam,
        variables: { input }
      })
      return result.data.startExam
    } catch (error) {
      console.error('Error starting exam:', error)
      throw error
    }
  }

  static async getExamSession(sessionId: string): Promise<ExamSession | null> {
    try {
      const result = await client.graphql({
        query: queries.getExamSession,
        variables: { id: sessionId }
      })
      return result.data.getExamSession
    } catch (error) {
      console.error('Error fetching exam session:', error)
      throw error
    }
  }

  static async saveExamProgress(input: SaveProgressInput): Promise<ExamSession> {
    try {
      const result = await client.graphql({
        query: mutations.saveExamProgress,
        variables: { input }
      })
      return result.data.saveExamProgress
    } catch (error) {
      console.error('Error saving exam progress:', error)
      throw error
    }
  }

  static async submitExam(sessionId: string): Promise<ExamResult> {
    try {
      const result = await client.graphql({
        query: mutations.submitExam,
        variables: { sessionId }
      })
      return result.data.submitExam
    } catch (error) {
      console.error('Error submitting exam:', error)
      throw error
    }
  }
}

export class ResultAPI {
  static async getExamResult(resultId: string): Promise<ExamResult | null> {
    try {
      const result = await client.graphql({
        query: queries.getExamResult,
        variables: { id: resultId }
      })
      return result.data.getExamResult
    } catch (error) {
      console.error('Error fetching exam result:', error)
      throw error
    }
  }
}

export class UserAPI {
  static async getUserProfile(userId: string): Promise<UserProfile | null> {
    try {
      const result = await client.graphql({
        query: queries.getUserProfile,
        variables: { id: userId }
      })
      return result.data.getUserProfile
    } catch (error) {
      console.error('Error fetching user profile:', error)
      throw error
    }
  }

  static async createUserProfile(input: Omit<UserProfile, 'createdAt' | 'updatedAt'>): Promise<UserProfile> {
    try {
      const result = await client.graphql({
        query: mutations.createUserProfile,
        variables: { input }
      })
      return result.data.createUserProfile
    } catch (error) {
      console.error('Error creating user profile:', error)
      throw error
    }
  }

  static async updateUserProfile(input: Partial<UserProfile> & { userId: string }): Promise<UserProfile> {
    try {
      const result = await client.graphql({
        query: mutations.updateUserProfile,
        variables: { input }
      })
      return result.data.updateUserProfile
    } catch (error) {
      console.error('Error updating user profile:', error)
      throw error
    }
  }
}

// Utility functions
export const APIUtils = {
  handleError: (error: any) => {
    if (error.errors) {
      // GraphQL errors
      const messages = error.errors.map((e: any) => e.message).join(', ')
      throw new Error(`GraphQL Error: ${messages}`)
    } else if (error.message) {
      throw new Error(error.message)
    } else {
      throw new Error('Unknown API error')
    }
  },

  formatFilters: (filters: QuestionFilters) => {
    // Convert filters to GraphQL format
    const graphqlFilter: any = {}
    
    if (filters.certification) {
      graphqlFilter.certification = { eq: filters.certification }
    }
    
    if (filters.domain) {
      graphqlFilter.domain = { eq: filters.domain }
    }
    
    if (filters.difficulty) {
      graphqlFilter.difficulty = { eq: filters.difficulty }
    }
    
    if (filters.tags && filters.tags.length > 0) {
      graphqlFilter.tags = { contains: filters.tags[0] } // Simple implementation
    }
    
    return graphqlFilter
  }
}